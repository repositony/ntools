//! Conversion to Visual Toolkit (VTK) formats
//!
//! This module handles all the conversions of weight window sets to Visual
//! Toolkit formats, and is mostly a coupling layer between internal types and
//! the `vtkio` crate.
//!
//! # Overview
//!
//! The intended workflow is to:
//!
//! 1. Configure the converter
//! 2. Convert into a `vtkio` VTK
//! 3. Write to file in the required format with [write_vtk()]
//!
//! Often the default configuration will suffice. The convenience function
//! [weights_to_vtk()] will quickly convert to a VTK ready for writing with
//! [write_vtk()].
//!
//! ```rust, no_run
//! # use ntools_weights::vtk::{weights_to_vtk, write_vtk, VtkFormat};
//! # use ntools_weights::WeightWindow;
//! // Convert to VTK with the default configuration
//! let vtk = weights_to_vtk(&WeightWindow::default());
//!
//! // Wite the VTK to a file in one of several formats
//! write_vtk(vtk, "output.vtk", VtkFormat::Xml).unwrap();
//! ```
//!
//! For more comprehensive examples, see the relevant struct documentation and
//! the next section.
//!
//! # Manual conversion
//!
//! The fields of [WeightsToVtk] are left public for direct use but builder
//! patterns are also implemented. A builder helps separate the configuration
//! from the conversion logic, and is often a style preference.
//!
//! The following examples are therefore equivalent.
//!
//! ## The builder approach:
//!
//! ```rust, no_run
//! # use ntools_weights::vtk::{WeightsToVtk, weights_to_vtk};
//! # use vtkio::{xml::Compressor, model::ByteOrder};
//! # use ntools_weights::WeightWindow;
//! // Make a new builder, change some values
//! let converter = WeightsToVtk::builder()
//!     .resolution(3)
//!     .compressor(Compressor::LZMA)
//!     .byte_order(ByteOrder::LittleEndian)
//!     .build();
//!
//! // Convert the weight windows using the parameters set
//! let vtk = weights_to_vtk(&WeightWindow::default());
//! ```
//!
//! ## The direct approach:
//!
//! ```rust, no_run
//! # use ntools_weights::vtk::{WeightsToVtk, weights_to_vtk};
//! # use ntools_weights::WeightWindow;
//! # use vtkio::{xml::Compressor, model::ByteOrder};
//! // Make a new instance, change some values
//! let mut converter = WeightsToVtk::new();
//! converter.resolution = 2;
//! converter.compressor = Compressor::LZMA;
//! converter.byte_order = ByteOrder::LittleEndian;
//!
//! // Convert the weight windows using the parameters set
//! let vtk = weights_to_vtk(&WeightWindow::default());
//! ```
//!
//! In the background, a call to [WeightsToVtk::new()] simply returns a default
//! configuration generated by the builder anyway.

mod builder;
mod convert;

#[doc(inline)]
pub use builder::WeightsToVtkBuilder;

#[doc(inline)]
pub use convert::WeightsToVtk;

use crate::error::Result;
use crate::WeightWindow;
use std::path::Path;
use vtkio::model::ByteOrder;
use vtkio::Vtk;

/// Convert a set of weight windows to vtk using default options
///
/// Suitable for quick conversions, but for control over conversion options
/// use [WeightsToVtk] and [WeightsToVtkBuilder] to change the configuration.
///
/// ```rust, no_run
/// # use ntools_weights::vtk::{weights_to_vtk, write_vtk, VtkFormat};
/// # use ntools_weights::WeightWindow;
/// // Dummy weight window set
/// let mut ww_set = WeightWindow::default();
///
/// // Convert to VTK with the default configuration
/// let vtk = weights_to_vtk(&ww_set);
/// ```
pub fn weights_to_vtk(weight_window: &WeightWindow) -> Vtk {
    WeightsToVtkBuilder::default()
        .build()
        .convert(weight_window)
}

/// Write any vtk to file
///
/// Takes any VTK and calls the appropriate vtkio writer depending on the
/// desired format.
///
/// The file format is set using variants of the [VtkFormat] enum. The
/// compression and endian options are set as part of the VTK, typically done
/// in the conversion phase.   
///
/// ```rust, no_run
/// # use ntools_weights::vtk::{weights_to_vtk, write_vtk, VtkFormat};
/// # use ntools_weights::WeightWindow;
/// // Dummy weight window set
/// let mut ww_set = WeightWindow::default();
///
/// // Convert to VTK with the default configuration
/// let vtk = weights_to_vtk(&ww_set);
///
/// // Wite the VTK to a file in one of several formats
/// write_vtk(vtk, "output.vtk", VtkFormat::Xml).unwrap();
/// ```
///
/// Note that if this is called manually the path extension must be correct or
/// vtkio will get thow and error.
///
/// For XML, the file must end in `.vtr` for rectangular meshes (rectilinear
/// grid), and `.vtu` for cylindrical meshes (unstructured). For both legacy
/// formats `.vtk` will work fine.
pub fn write_vtk(vtk: Vtk, path: impl AsRef<Path>, format: VtkFormat) -> Result<()> {
    match format {
        VtkFormat::Xml => Ok(vtk.export(path)?),
        VtkFormat::LegacyBinary => match vtk.byte_order {
            ByteOrder::BigEndian => Ok(vtk.export_be(path)?),
            ByteOrder::LittleEndian => Ok(vtk.export_le(path)?),
        },
        VtkFormat::LegacyAscii => Ok(vtk.export_ascii(path)?),
    }
}

/// Enum of VTK output formats
///
/// [VtkFormat::Xml] is recommended as the most modern format that also supports
/// compression to reduce file sizes.
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub enum VtkFormat {
    /// Extensible Markup Language (xml)
    Xml,
    /// ASCII text file
    LegacyAscii,
    /// ASCII headers with binary data
    LegacyBinary,
}

/// Vertex for use in cylindrical and unstructured mesh types
pub struct Vertex {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}

impl Vertex {
    /// turn vertex into a vector, rounding to 5 decimal places for consistency
    pub fn as_array(&self) -> [f64; 3] {
        [Self::rnd(self.x), Self::rnd(self.y), Self::rnd(self.z)]
    }

    /// Pass along simple translations by (x,y,z) cartesian coordinates
    pub fn translate(mut self, origin: &[f64; 3]) -> Vertex {
        self.x += origin[0];
        self.y += origin[1];
        self.z += origin[2];
        self
    }

    /// Force rounding of f64 to 5 decimal places
    ///
    /// Makes absolutely sure the vertex points are not slightly off due to f64
    /// rounding errors. The points in meshtal files are are only to 5 decimal
    /// places anyway so this should not lose precision.
    pub fn rnd(value: f64) -> f64 {
        let factor: f64 = (10_f64).powf(5.0);
        (factor * value).round() / factor
    }
}
