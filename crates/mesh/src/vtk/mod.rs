//! Conversion to Visual Toolkit (VTK) formats
//!
//! This module handles all the conversions of various mesh types to Visual
//! Toolkit formats, and is mostly a coupling layer between internal types and
//! the vtkio crate.
//!
//! # Overview
//!
//! The intended workflow is to:
//!
//! 1. Configure the converter
//! 2. Convert into a `vtkio` VTK
//! 3. Write to file in the required format with [write_vtk()]
//!
//! Often the default configuration will suffice. The convenience function
//! [mesh_to_vtk()] will quickly convert to a VTK ready for writing with
//! [write_vtk()].
//!
//! ```rust, no_run
//! # use ntools_mesh::vtk::{mesh_to_vtk, write_vtk, VtkFormat};
//! # use ntools_mesh::{Mesh, read_meshtal_target};
//! // Get a mesh
//! let mesh = read_meshtal_target("path/to/file.msht", 104).unwrap();
//!
//! // Convert to VTK with the default configuration
//! let vtk = mesh_to_vtk(&mesh);
//!
//! // Wite the VTK to a file in one of several formats
//! write_vtk(vtk, "output.vtk", VtkFormat::Xml).unwrap();
//! ```
//!
//! For more comprehensive examples, see the relevant struct documentation and
//! the next section.
//!
//! # Manual conversion
//!
//! The fields of [MeshToVtk] are left public for direct use but builder
//! patterns are also implemented. A builder helps separate the configuration
//! from the conversion logic, and is often a style preference.
//!
//! The following examples are therefore equivalent.
//!
//! ## The builder approach:
//!
//! ```rust
//! # use ntools_mesh::vtk::{MeshToVtk, MeshToVtkBuilder};
//! # use ntools_mesh::{Mesh, Group};
//! # let mesh = Mesh::default();
//! // Make a new builder, change some values
//! let converter = MeshToVtk::builder()
//!     .include_errors(true)
//!     .energy_groups(vec![0]) // first group
//!     .resolution(3)
//!     .build();
//!
//! // Convert the mesh using the parameters set
//! let vtk = converter.convert(&mesh);
//! ```
//!
//! ## The direct approach:
//!
//! ```rust
//! # use ntools_mesh::vtk::{MeshToVtk, MeshToVtkBuilder};
//! # use ntools_mesh::{Mesh, Group};
//! # let mesh = Mesh::default();
//! // Make a new instance, change some values
//! let mut converter = MeshToVtk::new();
//! converter.include_errors = true;
//! converter.energy_groups = vec![0]; // first group
//! converter.resolution = 3;
//!
//! // Convert the mesh using the parameters set
//! let vtk = converter.convert(&mesh);
//! ```
//!
//! In the background, a call to [MeshToVtk::new()] simply returns a default
//! configuration generated by the builder anyway.

mod builder;
mod convert;

#[doc(inline)]
pub use builder::MeshToVtkBuilder;

#[doc(inline)]
pub use convert::MeshToVtk;

use std::path::Path;
use vtkio::model::ByteOrder;
use vtkio::Vtk;

use crate::error::Result;
use crate::mesh::Mesh;

/// Convert a mesh tally to vtk using default options
///
/// Suitable for very quick conversions, but for control over conversion options
/// use [MeshToVtk] and the [MeshToVtkBuilder] to change the configuration.
///
/// ```rust, no_run
/// # use ntools_mesh::vtk::{mesh_to_vtk, write_vtk, VtkFormat};
/// # use ntools_mesh::{Mesh, read_meshtal_target};
/// // Get a mesh
/// let mesh = read_meshtal_target("path/to/file.msht", 104).unwrap();
///
/// // Convert to VTK with the default configuration
/// let vtk = mesh_to_vtk(&mesh);
///
/// // Wite the VTK to a file in one of several formats
/// write_vtk(vtk, "output.vtk", VtkFormat::Xml).unwrap();
/// ```
pub fn mesh_to_vtk(mesh: &Mesh) -> Vtk {
    MeshToVtkBuilder::default().build().convert(mesh)
}

/// Write any vtk to file
///
/// Takes any VTK and calls the appropriate vtkio writer depending on the
/// desired format.
///
/// The file format is set using variants of the [VtkFormat] enum. The
/// compression and endian options are set as part of the VTK, typically done
/// in the conversion phase.   
///
/// ```rust, no_run
/// # use ntools_mesh::{Mesh, read_meshtal_target, mesh_to_vtk, write_vtk};
/// # use ntools_mesh::vtk::VtkFormat;
/// // Get a mesh
/// let mesh = read_meshtal_target("path/to/file.msht", 104).unwrap();
///
/// // Convert to VTK with the default configuration
/// let vtk = mesh_to_vtk(&mesh);
///
/// // Wite the VTK to a file in one of several formats
/// write_vtk(vtk, "output.vtk", VtkFormat::Xml).unwrap();
/// ```
///
/// Note that if this is called manually the path extension must be correct or
/// vtkio will get thow and error.
///
/// For XML, the file must end in `.vtr` for rectangular meshes (rectilinear
/// grid), and `.vtu` for cylindrical meshes (unstructured). For both legacy
/// formats `.vtk` will work fine.
pub fn write_vtk(vtk: Vtk, path: impl AsRef<Path>, format: VtkFormat) -> Result<()> {
    match format {
        VtkFormat::Xml => Ok(vtk.export(path)?),
        VtkFormat::LegacyBinary => match vtk.byte_order {
            ByteOrder::BigEndian => Ok(vtk.export_be(path)?),
            ByteOrder::LittleEndian => Ok(vtk.export_le(path)?),
        },
        VtkFormat::LegacyAscii => Ok(vtk.export_ascii(path)?),
    }
}

/// Enum of VTK output formats
///
/// [VtkFormat::Xml] is recommended as the most modern format that also supports
/// compression to reduce file sizes.
#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub enum VtkFormat {
    /// Extensible Markup Language (xml)
    Xml,
    /// ASCII text file
    LegacyAscii,
    /// ASCII headers with binary data
    LegacyBinary,
}

/// Vertex for use in cylindrical and unstructured mesh types
pub struct Vertex {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}

impl Vertex {
    /// turn vertex into a vector, rounding to 5 decimal places for consistency
    pub fn as_array(&self) -> [f64; 3] {
        [Self::rnd(self.x), Self::rnd(self.y), Self::rnd(self.z)]
    }

    /// Pass along simple translations by (x,y,z) cartesian coordinates
    pub fn translate(mut self, origin: &[f64; 3]) -> Vertex {
        self.x += origin[0];
        self.y += origin[1];
        self.z += origin[2];
        self
    }

    /// Force rounding of f64 to 5 decimal places
    ///
    /// Makes absolutely sure the vertex points are not slightly off due to f64
    /// rounding errors. The points in meshtal files are are only to 5 decimal
    /// places anyway so this should not lose precision.
    pub fn rnd(value: f64) -> f64 {
        let factor: f64 = (10_f64).powf(5.0);
        (factor * value).round() / factor
    }
}
